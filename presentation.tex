\documentclass{beamer}
\usetheme{CambridgeUS}

\usepackage{color}
\usepackage{graphicx}
\usepackage{fancyvrb}
\usepackage[ascii]{inputenc}

\include{pygments}

\setbeamertemplate{frametitile}
{
  \begin{centering}
    \usebeamerfont{frametitle}\insertframetitle
    \par
    \ifx\insertframesubtitle\@empty
    \else
      { \usebeamerfont{framesubtitle}\usebeamercolor[fg]{framesubtitle}\insertframesubtitle\par}
    \fi
  \end{centering}
}

\title[Programming Competitions]{Intro to Programming Competitions}
\author[M. Wright \& C. Holgate]{Michael Wright and Carson Holgate}
\institute[NCSU]{
  Department of Computer Science\\
  North Carolina State University\\
  \texttt{mdwrigh2@ncsu.edu}\\
  \texttt{clholgat@ncsu.edu}
}

\date[February 2011]{February 22nd, 2011}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{What Competitions Are We Talking About?}
  \begin{centering}
    \begin{itemize}
      \item Competitions we \textbf{are} talking about are similar to:
      \begin{itemize}
        \item ACM ICPC
        \item IEEExtreme
        \item Facebook's Hacker Cup
      \end{itemize}
      \pause
      \item Competitions we \textbf{aren't} talking about:
      \begin{itemize}
        \item Project Euler
        \item Android Developer Challenge
        \item International Obfuscated C Contest
      \end{itemize}
    \end{itemize}
  \end{centering}
\end{frame}
       

\section{Competition Styles}

\begin{frame}{Group Work \& Reference Materials Allowed}

  \begin{centering}
    \begin{itemize}
      \item Group Work
      \begin{itemize}
        \item Individual
        \item Specific Group Members
        \item Limited Number of Group Members
        \item Unrestricted
      \end{itemize}
      \pause
      \item Reference Materials Allowed
      \begin{itemize}
        \item None
        \item Dead Trees
        \item Internets
        \item Anything
      \end{itemize}
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{Languages \& Time Frame}
  \begin{centering}
    \begin{itemize}
      \item Languages
      \begin{itemize}
        \item We'll talk about these a bit later
      \end{itemize}
      \pause
      \item Time Frame
      \begin{itemize}
        \item $<$ 24 hours (typically 3 - 5 hours)
        \item $\ge$ 24 hours (typically 24 - 72 hours)
      \end{itemize}
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{Submission \& Feedback}
  \begin{centering}
    \begin{itemize}
      \item Submission
      \begin{itemize}
        \item Source Code
        \item Output
        \item Both
      \end{itemize}
      \pause
      \item Feedback
      \begin{itemize}
        \item Immediate Feedback
        \begin{itemize}
          \item Exceptions Thrown
          \item Compile Errors
          \item Time Limit Exceeded
          \item Correct/Incorrect
        \end{itemize}
        \item End of Competition
      \end{itemize}
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{Time Restrictions \& Development Environment}
  \begin{centering}
    \begin{itemize}
      \item Time Restrictions
      \begin{itemize}
        \item Run-time sensitive
        \item Run-time insensitive
        \item All competitions are runtime sensitive to some degree (obviously). For some though, runtime is \textit{everything}.
      \end{itemize}
      \item Development Environment
      \begin{itemize}
        \item One computer provided
        \item Individual personal computers
      \end{itemize}
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{Competitors \& Expectations}
  \begin{centering}
    \begin{itemize}
      \item Competitors
      \begin{itemize}
        \item Academic - Undergraduates
        \item Academic - Students
        \item Open
      \end{itemize}
      \item Expectations
      \begin{itemize}
        \item Solved Most
        \item Solved All
      \end{itemize}
    \end{itemize}
  \end{centering}
\end{frame}
      


\begin{frame}{Example - ACM ICPC}
  \begin{centering}
    \begin{itemize}
      \item Specific Groups (Exactly 3)
      \item Dead Trees Available
      \item Languages Limited to C, C++, Java
      \item 5 hour time limit
      \item One computer for all 3 competitors
      \item ``Immediate" feedback (~15 minute delay)
      \item Source submission
      \item Generally not runtime sensitive
      \item Academic - Undergraduates
      \item Winners solve \textbf{most} of the problems (2009 ICPC winners solved 9 out of 12)
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{Example - IEEExtreme}
  \begin{centering}
    \begin{itemize}
      \item Limited Group Size (Up to 3)
      \item Internets
      \item Every competitor can bring their own computer(s)
      \item Languages Limited (C, C++, Java)
      \item 24 hour time limit (problems released every 6 hours)
      \item Immediate feedback (~3-5 minute delay)
      \item Source submission
      \item Generally not runtime sensitive
      \item Academic - Students
      \item Winners solve all the problems, then ranked by time to completion
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{Example - Facebook's Hacker Cup}
  \begin{centering}
    \begin{itemize}
      \item Individual
      \item Internets
      \item No limit to language (free compiler must be available)
      \item 3 hour time limit
      \begin{itemize}
        \item Max runtime is 6 minutes, but must be run on \textbf{your} system
        \item This is a very runtime sensitive competition
      \end{itemize}
      \item Immediate feedback (~3-5 minute delay)
      \item Source submission
      \item Academic - Students
    \end{itemize}
  \end{centering}
\end{frame}

  
\begin{frame}{Example - ICFP}
  \begin{centering}
    \begin{itemize}
      \item Unrestricted group size
      \item Internets
      \item No limit to language
      \item 72 hour time limit
      \item Both source and answer submission
      \item Open to anyone
      \item Only one problem to solve, but open ended, meaning whoever solves it ``best", wins
      \item Runtime is considered, but tends to be the absolute last measure considered (only matters when the other measurements are the same in every other way).
    \end{itemize}
  \end{centering}
\end{frame}

\section{Preparation \& Pitfalls}

\begin{frame}{Preparation - Individuals}
  \begin{centering}
    \begin{itemize}
      \item If the questions from previous years are available, use them!
      \item Books: Programming Challenges by Skiena and Revilla et al.
      \item Know the language you're going to use
      \item Familiarize yourself with the most useful algorithms. Implementing them in the language you have to use would be a \textbf{great} idea especially if you can bring your own code.
      \item Get to know your reference materials.
        \begin{itemize}
          \item Figure out which books you're using and know where to find what you will likely need (quick reference, specific algorithms)
          \item If it is open internet, bookmark the pages you'll use, close pages that will distract you before you go
          \item If you can use your computer or bring in electronic resources, consider getting PDFs of the algorithm books (Ctrl-F is your friend)
        \end{itemize}
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{Preparation - Groups}
  \begin{centering}
    \begin{itemize}
      \item Practice with your group!
      \item Roles for group members can be very useful. Typically broken down into:
      \begin{itemize}
        \item Programmer - Does all the typing (pick your fastest typer, or whoever knows the language best). Translates the pseudocode to real code, applies optimizations (dynamic programming, etc.)
        \item Solver - Determines the high level solution to the problem, maybe writes the pseudocode for it.
        \item Debugger - Looks at the pseudocode, tries to generate the test cases for it. If the real code has issues, walks through it to see where there could be errors, again generates test cases to see where it fails
        %\item These are \textbf{NOT} absolute roles. Everyone on your team should be able to fill any role when necessary. If a program is best implemented in C, the programmer may be someone different from whoever would be the programmer for a Java implementation. Someone may be really good at graph theory, so they're the solver for the graph theory problems while someone else is being the programmer. You have to be flexible, this is about optimizing everyone's time.
          \item These are \textbf{NOT} absolute roles. Everyone has to be flexible.
      \end{itemize}
      \pause
      \item Choose your group members carefully\ldots
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{Preparation - Day Of}
  \begin{centering}
    \begin{itemize}
      \item Bring whatever materials you're allowed. If books, an algorithms book, a reference for your language, etc.
      \item Pencil and paper! You can usually work out the smaller problems by hand, makes it easier to generate test cases, write pseudocode, etc.
      \item Whiteboard
      \item Boiler plate code if you're allowed (Data structure implementations, generic input reading code, etc.)
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{Pitfalls}
  \begin{centering}
    \begin{itemize}
      \item Input - Read the specification \textit{very} carefully
      \begin{itemize}
        \item Pay special attention to whether it can accept multiple test cases in one file
        \item Watch out for edge cases which usually aren't demonstrated in the given sample I/O
      \end{itemize}
      \item Whitespace
      \begin{itemize}
        \item Typically you'll receive example output. Pay special attention to all whitespace, particularly if dealing with it is part of the problem
      \end{itemize}

      \item Unless you know that runtime is a big part of the competition, optimize for programmer efficiency first.
      \item Know your primitive max and min values. You don't want to have an unnoticed overflow on an otherwise correct algorithm 
    \end{itemize}
  \end{centering}
\end{frame}

\section{Programming Languages}

\begin{frame}{Common Languages}
  \begin{centering}
    \begin{itemize}
     \item C
     \item C++
     \item Java
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{Less Common, but useful languages}
  \begin{centering}
    \begin{itemize}
      \item Python/Perl/Ruby
      \begin{itemize}
        \item These aren't uncommon languages, just uncommon to be on the list of restricted languages for programming contests today
      \end{itemize}
      \item LISP
      \item Haskell/OCaml/ML
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{C/C++}
  \begin{centering}
    \begin{itemize}
      \item Pros:
      \begin{itemize}
        \item Fast. If execution time is important this is probably your language of choice.
        \item C is very small, easy to know just about all of it
        \item Most algorithms have reference implementation in C and C++
        \item C++ has a huge standard lib. Learn it, love it
        \item Very common competition languages
      \end{itemize}
      \item Cons:
      \begin{itemize}
        \item Not typesafe
        \item Not all code is necessarily portable
        \item C has very few built-in data structures, meaning you'll have to write most by hand
        \item Bugs can be subtle
        \item Not easily read (an issue for group competitions)
      \end{itemize}
    \end{itemize}
  \end{centering}
\end{frame}



\begin{frame}{Java}
  \begin{centering}
    \begin{itemize}
      \item Pros:
      \begin{itemize}
        \item Common language for competitions
        \item Large standard library
        \item Relatively typesafe
        \item Memory managed
        \item Faster than dynamic languages, safer than C/C++
        \item More portable than C/C++
      \end{itemize}
      \item Cons:
      \begin{itemize}
        \item Slower than C/C++
        \item Very verbose
        \item Typesafety typically means you have to write more code
        \item Easier to read
      \end{itemize}
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{Python/Perl/Ruby}
  \begin{centering}
    \begin{itemize}
      \item Pros:
      \begin{itemize}
        \item Programmer time efficient
        \item Usually fast ``enough"
        \item Can be very readable
        \item REPL makes it easy to test particular components, quickly run test cases
        \item Large standard libs, easy to use custom objects.
      \end{itemize}
      \item Cons
      \begin{itemize}
        \item Relatively slow
        \item Lots of diversity, not everyone on your team will know a particular dynamic language
        \item Not commonly available in competitions with a restricted language set
      \end{itemize}
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{Others}
  \begin{centering}
    \begin{itemize}
      \item LISP
      \begin{itemize}
        \item Still a consistent winner in the AI problem space
        \item Higher order functions are incredibly useful
        \item Unfortunately, this is rarely an option, and most people don't know it
        \item Probably not worth learning for competitions, but useful if you already know it
      \end{itemize}
      \item Haskell/OCaml/ML
      \begin{itemize}
        \item A winner in some of the longer competitions (namely ICFP...)
        \item Typesafety gives you a lot more confidence your code
        \item Compiled code is very fast (comparable to C in some cases), and it is easier to reason in a recursive manner if you're used to this style
        \item Not something I'd learn for competitions, and likely of limited use (a LISP is probably the better option for competitions, if you want a similar language)
      \end{itemize}
    \end{itemize}
  \end{centering}
\end{frame}


\section{Algorithms, Data Structures and Thought Processes}

\begin{frame}{Algorithms, Data Structures, and Thought Processes}
  \begin{centering}
    \huge{Algorithms, Data Structures, and Thought Processes}
  \end{centering}
\end{frame}

\begin{frame}{Thought Processes}
  \begin{centering}
    \begin{itemize}
      \item Brute force solutions are okay - use them when it saves you programming and thinking time
      \item Recursive solutions are great. If you can make them tail recursive, there is little to no performance hit (with the right compiler). If the function is deterministic based on input, they're \textbf{very} easy to memoize, especially with dynamic languages
      \item Again, optimize only when necessary. Premature optimization  can cost you lots of time
      \item Break it up into discrete steps if possible. If you have multiple computers, agree on an output from one of the steps and you can parallelize the problem.
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{Data Structures}
  \begin{centering}
    \begin{itemize}
      \item Know your data structures cold
      \pause
      \item Data Structures
      \pause
      \item Data Structures
      \pause
      \item Data Structures
      \pause
      \item You should know things like:
      \begin{itemize}
        \item Linked Lists
        \item Arrays
        \item Stacks
        \item Queues
        \item Dictionaries
      \end{itemize}
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{Linked Lists}
  \begin{centering}
    \begin{itemize}
      \item Singly Linked
      \item Doubly Linked
      \item Circular
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{Arrays}
  \begin{centering}
    \begin{itemize}
     \item You should know these
     \item Great for lookup, or if you know how many items you're going to have (or if the max is reasonable, often it's not)
    \end{itemize}
  \end{centering}
\end{frame}

% create an array in python, show it, maybe sort it

\begin{frame}{Stacks}
  \begin{centering}
    \begin{itemize}
      \item LIFO or FILO data structure
      \item Arrays in some languages (e.g. python) can be used as stacks with their push and pop methods
      \item Good for things like depth-first traversal of graphs, backtracking solutions, etc.
      \item Also can be used to do things like check matching pairs 
      \begin{itemize}
        \item Example: Matching Parens
        \item Push '(' onto stack, on ')' pop it off. 
        \item If you try to pop on an empty stack, or at the end of the string the stack isn't empty, fail
        \item Otherwise all parens are matching, which is success.
      \end{itemize}
    \end{itemize}
  \end{centering}
\end{frame}

% Stacks implementation via python arrays

\begin{frame}{Queues}
  \begin{centering}
    \begin{itemize}
      \item Regular Queue
      \begin{itemize}
        \item A FIFO data structure
        \item Useful for breadth first searches in graphs, etc.
      \end{itemize}
      \item Priority Queue
      \begin{itemize}
        \item A data structure ordered by a specific attribute first, and then by the time they're inserted (FIFO)
        \item Example: Hospitals with patients
        \item Typically easier just to work with a sorted array or list, but if you need an efficient data structure for doing lots of inserts, this is the better choice
      \end{itemize}
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{Dictionaries}
  \begin{centering}
    \begin{itemize}
      \item Content-based retrieval, rather than position based
      \item Typically implemented with hash tables, but not necessarily
      \item Useful if your language has it, probably not worth implementing if it doesn't
    \end{itemize}
  \end{centering}
\end{frame}
% determining if a string has repeating letters

\begin{frame}{Strings}
  \begin{centering}
    \begin{itemize}
      \item Don't bother memorizing string searching algorithms (KMP, etc.)
      \item DO know how to process strings as input
      \begin{itemize}
        \item Reading stdin, files
        \item Extracting data from strings (str.split(),atoi(), scanf(), int())
      \end{itemize}
    \end{itemize}
  \end{centering}
\end{frame}
% Maybe show example input, read in with python

\begin{frame}{Numbers}
  \begin{centering}
    \begin{itemize}
      \item Primes - know what they are, know how to calculate them in a pinch
      \begin{itemize}
        \item If you have access to the internet, don't bother calculating them. There's at least the first 398 million available online in plaintext, separated by spaces, you should know how to read and use them.
      \end{itemize}
      \item Know how your language does arbitrary precision arithmetic (Java's BigInteger, GMP, etc.)
      \item Modular arithmetic - some number theory problems can be simplified.
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{Sorting}
  \begin{centering}
    \begin{itemize}
      \item Know the performance implications of sorting a list, performing actions (insert, lookup) on a sorted data structure
      \item Your language should have a good sorting implementation.
      \item If you are going to memorize one, make it quicksort.
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{Combinatorics}
  \begin{centering}
    \begin{itemize}
      \item Know basic combinatorics (how many combinations of these three groups of items I can have, etc.)
      \item Larger problems sometimes boil down to simple combinatorix.
      \pause
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{Graph Theory}
  \begin{centering}
    \begin{itemize}
      \item If you can bring your own code, this is what you should have. 
      \item Know at least one implementation of a directed graph in your chosen language.
      \item Algorithms to know:
        \begin{itemize}
          \item Breadth first search
          \item Depth first search
          \item Dijkestra's 
          \item Minimum Spanning Tree (Prim's, Kruskal's, et al.)
        \end{itemize}
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{Our Competition}
  \begin{centering}
    \begin{itemize}
      \item When: Saturday, Feb. 26, 10am-4pm
      \item Where: Withers 120
      \item Prizes: TBD (but they will exist!)
      \item Open group competition
      \item Internets + books + IRC
      \item BYOC 
    \end{itemize}
  \end{centering}
\end{frame}

\begin{frame}{The End}
  \centerline{\huge Questions?}
  \centerline{Comments?}
\end{frame}
  

\end{document}
